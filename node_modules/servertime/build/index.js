'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.middleware = middleware;
exports.addToResponse = addToResponse;
exports.start = start;
exports.end = end;
exports.timeMiddleware = timeMiddleware;
exports.createTimer = createTimer;

var _onHeaders = require('on-headers');

var _onHeaders2 = _interopRequireDefault(_onHeaders);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CLOCKS = {
    ms: {
        start: function start() {
            return Date.now();
        },
        diff: function diff(start) {
            return Date.now() - start;
        }
    },
    hr: {
        start: function start() {
            return process.hrtime();
        },
        diff: function diff(start) {
            var _process$hrtime = process.hrtime(start),
                _process$hrtime2 = _slicedToArray(_process$hrtime, 2),
                seconds = _process$hrtime2[0],
                nanos = _process$hrtime2[1];
            // Convert to milliseconds


            return seconds * 1000 + nanos / 1000000;
        }
    }
};

/**
 * Keeps track of timing data for events and turns that data into a `server-timing` header.
 */

var Timer = function () {
    function Timer() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck(this, Timer);

        this._isDummy = options.isDummy;
        this._clock = options.clock;
        this._records = {};
    }

    /**
     * Start timing an event.
     * @param {string} slug - The slug to use for timing.  The same slug must be supplied to `end(slug)` in order
     *   for this timing to show up in the final header.
     * @param {string} [label] - Label to use in the server-timing header.
     */


    _createClass(Timer, [{
        key: 'start',
        value: function start(slug) {
            var label = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

            if (this._isDummy) {
                return;
            }
            if (this._records[slug]) {
                console.error('serverTime: Attempting to add slug we\'ve already seen ' + slug);
            } else {
                this._records[slug] = {
                    label: label || slug,
                    start: this._clock.start()
                };
            }
        }

        /**
         * Stop timing an event.
         * @param {string} slug - The slug to supplied to `start()`.
         */

    }, {
        key: 'end',
        value: function end(slug) {
            if (this._isDummy) {
                return;
            }
            var record = this._records[slug];
            if (record) {
                record.time = this._clock.diff(record.start);
            }
        }

        /**
         * Set the timing for an event.
         * @param {string} slug - The slug to use for timing.
         * @param {string} [label] - Label to use in the server-timing header.
         * @param {number} ms - Time, in milliseconds.  Can be a float.
         */

    }, {
        key: 'setTime',
        value: function setTime(slug, label, ms) {
            if (ms === undefined) {
                ms = label;
                label = null;
            }

            this._records[slug] = {
                label: label || slug,
                time: ms
            };
        }

        /**
         * Time the duration of a promise.
         * @param {string} slug - The slug to use for timing.
         * @param {string} [label] - Label to use in the server-timing header.
         * @param {Promise} promise - The promise to time.
         * @return {Promise} - Returns the passed in `promise`.
         */

    }, {
        key: 'timePromise',
        value: function timePromise(slug, label, promise) {
            var _this = this;

            if (!promise) {
                promise = label;
                label = slug;
            }

            if (!this._isDummy) {
                this.start(slug, label);
                promise.then(function () {
                    return _this.end(slug);
                }, function () {
                    return _this.end(slug);
                });
            }

            return promise;
        }

        /**
         * Return the server-timing header.
         * @return {string} - The header.
         */

    }, {
        key: 'getHeader',
        value: function getHeader() {
            var _this2 = this;

            if (this._isDummy) {
                return null;
            }

            return Object.keys(this._records)
            // Filter out any results where we never called 'end'
            .filter(function (slug) {
                return 'time' in _this2._records[slug];
            }).map(function (slug) {
                return slug + '=' + _this2._records[slug].time + '; "' + _this2._records[slug].label + '"';
            }).join(', ');
        }
    }]);

    return Timer;
}();

/**
 * Returns an express-style middleware that automatically adds `res.serverTiming` to the resposne object.
 *
 * @param  {Object} [options={}] - Options.
 * @param  {boolean} [options.devOnly=true] - If truthy, then only add a 'server-timing' header when NODE_ENV
 *   is not "production".  Server timing information can reveal a lot about your infrastructure to a potential
 *   attacker, so be careful with this.
 * @param  {string} [options.clock=hr] - The default is 'hr' which uses `process.hrtime()` to get nanosecond accuracy,
 *   but if you're on a platform that doesn't support `process.hrtime()` you can pass in 'ms' to use `Date.now()`
 *   instead.
 * @return {function} A `function(req, res, next)` express-style middleware.  Note that `next` is optional.
 */


function middleware() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    return function (req, res, next) {
        addToResponse(res, options);
        if (next) {
            next();
        }
    };
}

/**
 * Sets up a request to
 *
 * @param {http.ServerResponse} res - The resposne object.  `res.serverTiming` will be set to a new `Timer` object.
 *   `res.setHeader()` will automatically be called with the new header.
 * @param  {Object} [options={}] - Options.
 * @param  {boolean} [options.devOnly=true] - If truthy, then only add a 'server-timing' header when NODE_ENV
 *   is not "production".  Server timing information can reveal a lot about your infrastructure to a potential
 *   attacker, so be careful with this.
 * @param  {string} [options.clock] - The default is 'hr' which uses `process.hrtime()` to get nanosecond accuracy,
 *   but if you're on a platform that doesn't support `process.hrtime()` you can pass in 'ms' to use `Date.now()`
 *   instead.
 */
function addToResponse(res) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var devOnly = 'devOnly' in options ? options.devOnly : true;
    var clock = CLOCKS[options.clock || 'hr'];

    // Don't add this twice.
    if (res.serverTiming) {
        return;
    }

    // If we're not in production, then do nothing.  Add a `dummy` serverTiming so caller code doesn't
    // need to change.
    if (devOnly && process.env.NODE_ENV === 'production') {
        res.serverTiming = new Timer({ isDummy: true, clock: clock });
        return;
    }

    res.serverTiming = new Timer({ clock: clock });

    (0, _onHeaders2.default)(res, function () {
        if (!this.getHeader('server-timing')) {
            this.setHeader('server-timing', res.serverTiming.getHeader());
        }
    });
}

/**
 * Returns a mini-middleware that calls `res.serverTiming.start(slug, label)`.
 *
 * @param {string} slug - The slug to use for timing.  The same slug must be supplied to `end(slug)` in order
 *   for this timing to show up in the final header.
 * @param {string} [label] - Label to use in the server-timing header.
 * @return {function} - Middleware function.
 */
function start(slug) {
    var label = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    return function (req, res, next) {
        res.serverTiming.start(slug, label);
        if (next) {
            next();
        }
    };
}

/**
 * Returns a mini-middleware that calls `res.serverTiming.end(slug, label)`.
 *
 * @param {string} slug - The slug to supplied to `start()`.
 * @return {function} - Middleware function.
 */
function end(slug) {
    return function (req, res, next) {
        res.serverTiming.end(slug);
        if (next) {
            next();
        }
    };
}

/**
 * Wraps a middleware and adds timing data for it to the server-timing header.
 *
 * @param {string} slug - The slug to use for timing.
 * @param {string} [label] - Label to use in the server-timing header.
 * @param {function} middleware - The `fn(req, res, next)` function to time.  Note that the function must call
 *   `next()` in order to be timed.
 * @return {function} - Middleware function.
 */
function timeMiddleware(slug, label, middleware) {
    if (!middleware) {
        middleware = label;
        label = slug;
    }

    return function (req, res, next) {
        res.serverTiming.start(slug, label);
        middleware(req, res, function (err) {
            res.serverTiming.end(slug);
            next(err);
        });
    };
}

/**
 * Create a new Timer object.
 * @param  {object} [options={}] - Options.
 * @param  {string} [options.clock=hr] - The default is 'hr' which uses `process.hrtime()` to get nanosecond accuracy,
 *   but if you're on a platform that doesn't support `process.hrtime()` you can pass in 'ms' to use `Date.now()`
 *   instead.
 * @return {Timer} - New Timer object.
 */
function createTimer() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var clock = CLOCKS[options.clock || 'hr'];
    return new Timer({ clock: clock });
}
//# sourceMappingURL=index.js.map